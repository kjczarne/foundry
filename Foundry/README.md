# Foundry

## Foundry vs. Refinery

Foundry is a minimal Refinery Framework implementation that provides a bare-bones source to target transformation API as a CLI tool. What we realized with Refinery 0.2-alpha was that the current setup was too reliant on a backing database and too tied to a specific technological stack with CouchDB in the background. Refinery didn't offer any way to directly transform one resource into another without the need to deploy a backing instance of CouchDB.

We went back to the drawing board just to realize that minimal design is best design. By making less assumptions about the final form of the system on the users' end, we realized that there is potentially much more power in a tool that does the transformation part in a consistent and more scalable way. With Foundry we're attempting to focus on that particular requirement and we're building a minimial, less confusing tool that does one thing very very well and leaves all the other open-ended questions like the choice of the database or transfer and sync logic in the hands of the end user.

### Why the change from TS to F#

With TypeScript the original goal was to take leverage of general familiarity of languages from JS family and to speed up time to market, focusing less on the performance and putting forth a working prototype. Refinery's design assumes an ever-present CouchDB instance maintained by the user to facilitate data storage. But at some point we realized that technically any other storage backend could be used to the users' liking. That is, not only conventional databases but maybe commercial productivity tools that strongly follow database design principles, like Notion. So a decision was made to get rid of CouchDB and provide yet better capabilities for the project to just transform one type of resource to another, possibly by connecting to APIs the likes of Notion instead of implementing its own database. We rethought the technology stack and we realized that selecting F# as the programming language for this project offers a few major improvements over the previous system:

* FP -> The functional approach does away with OOP constructs that increase code complexity and make the maintenance of a project messier as it grows. FP is also more suitable when working with anything that has to do with any sort of abstractions around processing some sort of input into some sort of output. FP can be done in TS or JS but using a functional-first language means one doesn't have to take special care about immutability constraints and pure functions, as these are directly enforced by F#'s compiler.
* .NET -> F# is a .NET language which means it can take advantage of a number of perks, especially now with the Mono AOT Compiler coming to .NET, there will be major performance gains when developing for .NET.
* Parallelization -> F# is easily parallelizable if you use it the way it was intended to be used, i.e. in the functional paradigm. Pure functions and immutability mean safer threading and the ability to parallelize processes in distributed computing model in the future. This may prove useful to the users when processing large amounts of data.
* Portability -> With the advent of .NET Core, Microsoft really took multiplatform development to their hearts. Thanks to this Foundry should be deployable on most of the existing operating systems in the world with little to no overhead.
* Interoperability -> Any logic implemented in .NET can make use of nearly any other low-level language logic. Interop with unmanaged code on .NET is relatively easy which makes it a great choice for developers who want to implement a general-purpose project like ours.
* Syntax -> Last but not least, F#'s syntax is easy to learn, clear, concise and in many instances reminiscent of mathematical notation. It's pleasure to use and pleasure to maintain.

A number of the points above talk about .NET and this probably begs the question: why not C#? There are lot more C# devs in the world right now than F# developers and F# is more of a niche programming language. Probably the strongest point that led us away from C# was it's insane level of verbosity and insuitability for functional-first constructs, as it takes way more lines of code to e.g. get a delegate to do what you want in C# as opposed to using functional composition in F#. While C# makes sense for many commercial projects, particularly because of the programming talent availability, this is not a commercial project and we feel there is more value in selecting the right tool for the job instead of trying to force another programming language into a paradigm that it wasn't cut out for.